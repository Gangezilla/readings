<canvas id="canvas" width="600" height="600" style="border: 1px grey solid">
  <script>
    const VIEWPORT_SIZE = 1;
    const PROJECTION_PLACE_Z = 1;
    const CAMERA_POSITION = [0, 0, 0];
    const BACKGROUND_COLOR = [255, 255, 255];

    const canvas = document.getElementById("canvas");
    const canvasContext = canvas.getContext("2d");
    let canvasBuffer = canvasContext.getImageData(
      0,
      0,
      canvas.width,
      canvas.height
    );
    const canvasPitch = canvasBuffer.width * 4;

    function putPixel(x, y, color) {
      x = canvas.width / 2 + x;
      y = canvas.height / 2 - y - 1;

      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return;
      }

      let offset = 4 * x + canvasPitch * y;
      canvasBuffer.data[offset++] = color[0];
      canvasBuffer.data[offset++] = color[1];
      canvasBuffer.data[offset++] = color[2];
      canvasBuffer.data[offset++] = 255; // full opacity
    }

    // Displays
    function updateCanvas() {
      canvasContext.putImageData(canvasBuffer, 0, 0);
    }

    // Linear algebra and helpers
    const dotProduct = (v1, v2) =>
      v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    const length = vec => Math.sqrt(dotProduct(vec, vec));
    const multiply = (k, vec) => [k * vec[0], k * vec[1], k * vec[2]];
    const add = (v1, v2) => [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
    const subtract = (v1, v2) => [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
    const clamp = vec => [
      // clamp color to range
      Math.min(255, Math.max(0, vec[0])),
      Math.min(255, Math.max(0, vec[1])),
      Math.min(255, Math.max(0, vec[2]))
    ];

    // Objects
    let Sphere = function(center, radius, color) {
      this.center = center;
      this.radius = radius;
      this.color = color;
    };

    let Light = function(ltype, intensity, position) {
      this.ltype = ltype;
      this.intensity = intensity;
      this.position = position;
    };

    Light.AMBIENT = 0;
    Light.POINT = 1;
    Light.DIRECTIONAL = 2;

    // Raytracer
    // Scene setup
    const spheres = [
      new Sphere([0, -1, 3], 1, [255, 0, 0]),
      new Sphere([2, 0, 4], 1, [0, 0, 255]),
      new Sphere([-2, 0, 4], 1, [0, 255, 0]),
      new Sphere([0, -5001, 0], 5000, [255, 255, 0])
    ];

    const lights = [
      new Light(Light.AMBIENT, 0.2),
      new Light(Light.POINT, 0.6, [2, 1, 0]),
      new Light(Light.DIRECTIONAL, 0.2, [1, 4, 4])
    ];

    // converts 2d canvas coordinates to 3d viewport coordinates
    const canvasToViewport = p2d => [
      (p2d[0] * VIEWPORT_SIZE) / canvas.width,
      (p2d[1] * VIEWPORT_SIZE) / canvas.height,
      PROJECTION_PLACE_Z
    ];

    // computes the intersection of a ray and a sphere. Returns the values of t for the intersection.
    // using the quadratic equation
    const intersectRaySphere = (origin, direction, sphere) => {
      const oc = subtract(origin, sphere.center);

      const k1 = dotProduct(direction, direction);
      const k2 = 2 * dotProduct(oc, direction);
      const k3 = dotProduct(oc, oc) - sphere.radius * sphere.radius;

      const discriminant = k2 * k2 - 4 * k1 * k3;
      if (discriminant < 0) {
        return [Infinity, Infinity];
      }

      const t1 = (-k2 + Math.sqrt(discriminant)) / (2 * k1);
      const t2 = (-k2 - Math.sqrt(discriminant)) / (2 * k1);
      return [t1, t2];
    };

    const computeLighting = (point, normal) => {
      let intensity = 0;
      const lengthN = length(normal);

      for (let i = 0; i < lights.length; i++) {
        let light = lights[i];
        if (light.ltype === Light.AMBIENT) {
          intensity += light.intensity;
        } else {
          let vecL;
          if (light.ltype == Light.POINT) {
            vecL = subtract(light.position, point);
          } else {
            vecL = light.position;
          }

          const nDotL = dotProduct(normal, vecL);
          if (nDotL > 0) {
            intensity += (light.intensity * nDotL) / (lengthN * length(vecL));
          }
        }
      }

      return intensity;
    };

    // traces a ray against the set of spheres in the scene
    const traceRay = (origin, direction, minT, maxT) => {
      let closestT = Infinity;
      let closestSphere = null;

      for (let i = 0; i < spheres.length; i++) {
        const ts = intersectRaySphere(origin, direction, spheres[i]);
        if (ts[0] < closestT && minT < ts[0] && ts[0] < maxT) {
          closestT = ts[0];
          closestSphere = spheres[i];
        }
        if (ts[1] < closestT && minT < ts[1] && ts[1] < maxT) {
          cloestT = ts[1];
          closestSphere = spheres[i];
        }
      }

      if (closestSphere == null) {
        return BACKGROUND_COLOR;
      }

      const point = add(origin, multiply(closestT, direction));
      let normal = subtract(point, closestSphere.center);
      normal = multiply(1.0 / length(normal), normal);

      return multiply(computeLighting(point, normal), closestSphere.color);
    };

    for (let x = -canvas.width / 2; x < canvas.width / 2; x++) {
      for (let y = -canvas.height / 2; y < canvas.height / 2; y++) {
        const direction = canvasToViewport([x, y]);
        const color = traceRay(CAMERA_POSITION, direction, 1, Infinity);
        putPixel(x, y, clamp(color));
      }
    }

    updateCanvas();
  </script></canvas
>
